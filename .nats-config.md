# NATS MCP Server Configuration - Efficiency Guidelines

**Last Updated:** 2026-01-02
**Purpose:** Reduce context consumption when reading NATS messages

---

## Message Reading Limits

**Default Behavior:**
- The `read_messages` tool defaults to 50 messages
- This can consume significant context (5,000-10,000 tokens)

**Recommended Limits:**

| Scenario | Limit | Use Case |
|----------|-------|----------|
| Quick status check | 5 | "What's the latest update?" |
| Recent work sync | 10 | "Catch up after 1-2 hours" |
| Full sync | 20 | "Catch up after being offline" |
| Deep history | 30 | "Need to understand recent issues" |
| **Never use** | 50+ | Too much context waste |

---

## Message Format Standards

### Keep Messages Concise

**Format:** `[Agent]: [Phase-Step] [Action] [Status] ‚Üí [Next/Notes]`

**Examples:**

```
‚úÖ Bob: P4-S3 lighting DONE. 4 lights, build OK ‚Üí Asheron validation
üîÑ Asheron: P4-S2 shader validation IN PROGRESS. ETA 15min
‚ùå Bob: P4-S2 shader compile ERROR. Fragment shader line 23. Fixing...
‚úÖ Asheron: P4-S2 APPROVED. 10/10 PASS ‚Üí Bob proceed S3
```

### Use Abbreviations

- **P4-S3** instead of "Phase 4 Step 3"
- **DONE/PASS/FAIL** instead of "completed successfully"
- **OK** instead of "successful"
- **ETA** instead of "estimated time"
- **‚Üí** instead of "ready for" or "next is"

### Status Emojis

- ‚úÖ Complete/Approved
- üîÑ In Progress
- ‚è∏Ô∏è Waiting/Blocked
- ‚ùå Failed/Error
- üö® Critical Issue

---

## Channel Usage Strategy

### Current Channels

1. **roadmap** - Project-wide roadmap updates
   - **Use for:** Phase completions, major milestones
   - **Don't use for:** Step-by-step progress
   - **Read limit:** 5 messages

2. **coordination** - Agent coordination and handoffs
   - **Use for:** Step completions, validation approvals, blockers
   - **Don't use for:** Internal implementation details
   - **Read limit:** 10 messages

3. **errors** - Error reporting and debugging
   - **Use for:** Build failures, validation failures, critical bugs
   - **Don't use for:** Expected errors (like linting warnings)
   - **Read limit:** 15 messages (errors need context)

### When to Read vs. Post

**Read coordination before:**
- Starting a new step (check if previous validated)
- After being offline >1 hour
- When blocked (check if someone posted solution)

**Don't read coordination:**
- After every single file edit
- Multiple times per step
- When you just posted (you know what's there)

**Post to coordination when:**
- Step complete (ready for validation)
- Validation complete (approval/issues)
- Blocked by dependency
- Critical error found

**Don't post to coordination:**
- Starting a step (just do it)
- Mid-step progress updates
- "Working on X..." status (waste)

---

## Phase-Specific Channels (Future)

If message volume increases, consider:

```
coordination-phase4  (Phase 4 work only)
coordination-phase5  (Phase 5 work only)
etc.
```

**Benefits:**
- Only read relevant phase messages
- Natural archiving when phase completes
- Reduces noise

---

## Message Archiving

When a phase completes:

1. Export messages to devlog
2. Clear phase-specific channel (if using)
3. Keep only "Phase X Complete" summary in main channels

**Archive format:**
```
devlog/nats-archive-phase{N}.md
```

---

## Example: Efficient Workflow

### Bob Completes Step 3

**Inefficient (‚ùå):**
```typescript
// Reads 50 messages (default)
read_messages({ channel: "coordination" })

// Posts verbose update (300 chars)
post_message({
  channel: "coordination",
  message: "Bob completed Phase 4 Workstream 4.1 Step 3 lighting system implementation. Implemented 4 lights: ambient, directional, point, spotlight with exact baseline specifications. Created 3 visual effects: beam, circle, grid. Build successful: TypeScript compiled in 1.5s, generation in 246ms. Zero errors. Baseline compliance 100%. ThreeScene.tsx now 323 lines. Ready for Asheron validation of lighting accuracy and visual effects."
})
```

**Efficient (‚úÖ):**
```typescript
// Reads only last 5 messages (recent context)
read_messages({ channel: "coordination", limit: 5 })

// Posts concise update (80 chars)
post_message({
  channel: "coordination",
  message: "‚úÖ Bob: P4-S3 lighting DONE. 4 lights+3effects, build OK ‚Üí Asheron validation"
})
```

**Context Saved:**
- Reading: ~8,000 tokens ‚Üí ~500 tokens (94% reduction)
- Posting: ~300 chars ‚Üí ~80 chars (73% reduction)

---

## Agent Instructions

### For Bob (Implementation)

**When starting a step:**
```typescript
// Quick check: Is previous step validated?
const messages = await read_messages({ channel: "coordination", limit: 5 })
// Look for Asheron's approval
```

**When completing a step:**
```typescript
// Post concise completion
await post_message({
  channel: "coordination",
  message: `‚úÖ Bob: P4-S${stepNum} ${stepName} DONE ‚Üí Asheron validation`
})
```

### For Asheron (Validation)

**When starting validation:**
```typescript
// Check what Bob completed
const messages = await read_messages({ channel: "coordination", limit: 5 })
// Look for Bob's completion message
```

**When completing validation:**
```typescript
// Post approval/issues
await post_message({
  channel: "coordination",
  message: `‚úÖ Asheron: P4-S${stepNum} APPROVED 10/10 PASS ‚Üí Bob proceed S${stepNum+1}`
})
```

---

## Monitoring

**Check if optimization is working:**

1. Monitor agent context usage
2. Check message length average (aim: <100 chars)
3. Verify no redundant posts (same agent posting multiple times in <5min)

**Target Metrics:**
- Average message length: <120 characters
- Messages per step: 2-3 (start, complete, validate)
- Channel reads per agent per hour: <5

---

**Maintained By:** Project Manager
**Review Schedule:** After each phase completion
